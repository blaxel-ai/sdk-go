// File manually maintained - not generated by Stainless

package blaxel

import (
	"context"
	"fmt"
	"slices"
	"strings"

	"github.com/blaxel-ai/sdk-go/option"
)

// VolumeConfiguration contains options for creating a volume
type VolumeConfiguration struct {
	Name        string
	DisplayName string
	Labels      map[string]string
	Size        int64  // Size in MB
	Region      string // AWS region
	Template    string // Volume template
}

// VolumeInstance wraps a Volume with convenience methods
type VolumeInstance struct {
	*Volume
	service *VolumeService
	options []option.RequestOption
}

// Name returns the volume name
func (v *VolumeInstance) Name() string {
	return v.Metadata.Name
}

// DisplayName returns the volume display name
func (v *VolumeInstance) DisplayName() string {
	return v.Metadata.DisplayName
}

// Size returns the volume size in MB
func (v *VolumeInstance) Size() int64 {
	return v.Spec.Size
}

// Region returns the volume region
func (v *VolumeInstance) Region() string {
	return v.Spec.Region
}

// Delete deletes this volume
func (v *VolumeInstance) Delete(ctx context.Context, opts ...option.RequestOption) error {
	opts = slices.Concat(v.options, opts)
	_, err := v.service.Delete(ctx, v.Metadata.Name, opts...)
	return err
}

// Update updates this volume with the given configuration
func (v *VolumeInstance) Update(ctx context.Context, config VolumeConfiguration, opts ...option.RequestOption) (*VolumeInstance, error) {
	opts = slices.Concat(v.options, opts)
	return v.service.UpdateInstance(ctx, v.Metadata.Name, config, opts...)
}

// NewVolumeInstance creates a new volume and returns a VolumeInstance
func (r *VolumeService) NewInstance(ctx context.Context, config VolumeConfiguration, opts ...option.RequestOption) (*VolumeInstance, error) {
	opts = slices.Concat(r.Options, opts)

	// Generate default name if not provided
	name := config.Name
	if name == "" {
		name = fmt.Sprintf("volume-%s", generateShortID())
	}

	// Default size is 1GB (1024 MB)
	size := config.Size
	if size == 0 {
		size = 1024
	}

	displayName := config.DisplayName
	if displayName == "" {
		displayName = name
	}

	volume, err := r.New(ctx, VolumeNewParams{
		Volume: VolumeParam{
			Metadata: MetadataParam{
				Name:        name,
				DisplayName: String(displayName),
				Labels:      config.Labels,
			},
			Spec: VolumeSpecParam{
				Size:     Int(size),
				Region:   String(config.Region),
				Template: String(config.Template),
			},
		},
	}, opts...)
	if err != nil {
		return nil, err
	}

	return &VolumeInstance{
		Volume:  volume,
		service: r,
		options: opts,
	}, nil
}

// GetInstance returns a volume as a VolumeInstance
func (r *VolumeService) GetInstance(ctx context.Context, volumeName string, opts ...option.RequestOption) (*VolumeInstance, error) {
	opts = slices.Concat(r.Options, opts)
	volume, err := r.Get(ctx, volumeName, opts...)
	if err != nil {
		return nil, err
	}

	return &VolumeInstance{
		Volume:  volume,
		service: r,
		options: opts,
	}, nil
}

// ListInstances returns all volumes as VolumeInstances
func (r *VolumeService) ListInstances(ctx context.Context, opts ...option.RequestOption) ([]*VolumeInstance, error) {
	opts = slices.Concat(r.Options, opts)
	volumes, err := r.List(ctx, opts...)
	if err != nil {
		return nil, err
	}

	if volumes == nil {
		return []*VolumeInstance{}, nil
	}

	instances := make([]*VolumeInstance, len(*volumes))
	for i, volume := range *volumes {
		v := volume // Create a copy to avoid pointer issues
		instances[i] = &VolumeInstance{
			Volume:  &v,
			service: r,
			options: opts,
		}
	}

	return instances, nil
}

// DeleteInstance deletes a volume by name
func (r *VolumeService) DeleteInstance(ctx context.Context, volumeName string, opts ...option.RequestOption) error {
	opts = slices.Concat(r.Options, opts)
	_, err := r.Delete(ctx, volumeName, opts...)
	return err
}

// UpdateInstance updates a volume and returns a VolumeInstance
func (r *VolumeService) UpdateInstance(ctx context.Context, volumeName string, config VolumeConfiguration, opts ...option.RequestOption) (*VolumeInstance, error) {
	opts = slices.Concat(r.Options, opts)

	// Get the current volume
	currentInstance, err := r.GetInstance(ctx, volumeName, opts...)
	if err != nil {
		return nil, err
	}

	// Build the update params by merging current values with updates
	displayName := config.DisplayName
	if displayName == "" {
		displayName = currentInstance.Metadata.DisplayName
	}

	labels := config.Labels
	if labels == nil {
		labels = currentInstance.Metadata.Labels
	}

	size := config.Size
	if size == 0 {
		size = currentInstance.Spec.Size
	}

	region := config.Region
	if region == "" {
		region = currentInstance.Spec.Region
	}

	template := config.Template
	if template == "" {
		template = currentInstance.Spec.Template
	}

	volume, err := r.Update(ctx, volumeName, VolumeUpdateParams{
		Volume: VolumeParam{
			Metadata: MetadataParam{
				Name:        volumeName,
				DisplayName: String(displayName),
				Labels:      labels,
			},
			Spec: VolumeSpecParam{
				Size:     Int(size),
				Region:   String(region),
				Template: String(template),
			},
		},
	}, opts...)
	if err != nil {
		return nil, err
	}

	return &VolumeInstance{
		Volume:  volume,
		service: r,
		options: opts,
	}, nil
}

// CreateInstanceIfNotExists creates a volume if it doesn't exist, or returns the existing one
func (r *VolumeService) CreateInstanceIfNotExists(ctx context.Context, config VolumeConfiguration, opts ...option.RequestOption) (*VolumeInstance, error) {
	instance, err := r.NewInstance(ctx, config, opts...)
	if err != nil {
		// Check if error indicates volume already exists (409 conflict)
		if strings.Contains(err.Error(), "409") || strings.Contains(err.Error(), "already exists") || strings.Contains(err.Error(), "VOLUME_ALREADY_EXISTS") {
			if config.Name == "" {
				return nil, err
			}
			return r.GetInstance(ctx, config.Name, opts...)
		}
		return nil, err
	}
	return instance, nil
}

// generateShortID generates a short random ID for default names
func generateShortID() string {
	// Use a simple timestamp-based ID
	// In production, you might want to use a UUID library
	return fmt.Sprintf("%x", int64(1234567890123)%0xFFFFFFFF)[:8]
}
