// File manually maintained - not generated by Stainless

package blaxel

import (
	"context"
	"crypto/rand"
	"encoding/json"
	"fmt"
	"os"
	"slices"
	"strings"
	"time"

	"github.com/blaxel-ai/sdk-go/option"
)

// VolumeUpdateMetadataParams contains parameters for updating volume metadata
type VolumeUpdateMetadataParams struct {
	Labels      map[string]string
	DisplayName string
}

// VolumeInstance wraps a Volume with convenience methods
type VolumeInstance struct {
	*Volume
	service *VolumeService
	options []option.RequestOption
}

// Name returns the volume name
func (v *VolumeInstance) Name() string {
	return v.Metadata.Name
}

// DisplayName returns the volume display name
func (v *VolumeInstance) DisplayName() string {
	return v.Metadata.DisplayName
}

// Size returns the volume size in MB
func (v *VolumeInstance) Size() int64 {
	return v.Spec.Size
}

// Region returns the volume region
func (v *VolumeInstance) Region() string {
	return v.Spec.Region
}

// Delete deletes this volume
func (v *VolumeInstance) Delete(ctx context.Context, opts ...option.RequestOption) error {
	opts = slices.Concat(v.options, opts)
	_, err := v.service.Delete(ctx, v.Metadata.Name, opts...)
	return err
}

// Update updates this volume with the given params
func (v *VolumeInstance) Update(ctx context.Context, body VolumeUpdateParams, opts ...option.RequestOption) (*VolumeInstance, error) {
	opts = slices.Concat(v.options, opts)
	return v.service.UpdateInstance(ctx, v.Metadata.Name, body, opts...)
}

// NewInstance creates a new volume and returns a VolumeInstance.
// This allows fluent access to volume operations:
//
//	vol, err := client.Volumes.NewInstance(ctx, blaxel.VolumeNewParams{
//	    Volume: blaxel.VolumeParam{
//	        Metadata: blaxel.MetadataParam{Name: "my-volume"},
//	        Spec: blaxel.VolumeSpecParam{
//	            Size:   blaxel.Int(1024),
//	            Region: blaxel.String("us-pdx-1"),
//	        },
//	    },
//	})
func (r *VolumeService) NewInstance(ctx context.Context, body VolumeNewParams, opts ...option.RequestOption) (*VolumeInstance, error) {
	opts = slices.Concat(r.Options, opts)

	// Generate default name if not provided
	if body.Volume.Metadata.Name == "" {
		body.Volume.Metadata.Name = fmt.Sprintf("volume-%s", generateShortID())
	}

	// Default size is 1GB (1024 MB)
	if !body.Volume.Spec.Size.Valid() || body.Volume.Spec.Size.Value == 0 {
		body.Volume.Spec.Size = Int(1024)
	}

	// Region is required
	if !body.Volume.Spec.Region.Valid() || body.Volume.Spec.Region.Value == "" {
		if region := os.Getenv("BL_REGION"); region != "" {
			body.Volume.Spec.Region = String(region)
		} else {
			return nil, fmt.Errorf("VolumeService.NewInstance: 'Region' is required. Please specify a region (e.g. 'us-pdx-1', 'eu-lon-1', 'us-was-1') in the volume spec or set the BL_REGION environment variable")
		}
	}

	// Default display name to name if not set
	if !body.Volume.Metadata.DisplayName.Valid() || body.Volume.Metadata.DisplayName.Value == "" {
		body.Volume.Metadata.DisplayName = String(body.Volume.Metadata.Name)
	}

	volume, err := r.New(ctx, body, opts...)
	if err != nil {
		return nil, err
	}

	return &VolumeInstance{
		Volume:  volume,
		service: r,
		options: opts,
	}, nil
}

// GetInstance returns a volume as a VolumeInstance
func (r *VolumeService) GetInstance(ctx context.Context, volumeName string, opts ...option.RequestOption) (*VolumeInstance, error) {
	opts = slices.Concat(r.Options, opts)
	volume, err := r.Get(ctx, volumeName, opts...)
	if err != nil {
		return nil, err
	}

	return &VolumeInstance{
		Volume:  volume,
		service: r,
		options: opts,
	}, nil
}

// ListInstances returns all volumes as VolumeInstances
func (r *VolumeService) ListInstances(ctx context.Context, opts ...option.RequestOption) ([]*VolumeInstance, error) {
	opts = slices.Concat(r.Options, opts)
	volumes, err := r.List(ctx, opts...)
	if err != nil {
		return nil, err
	}

	if volumes == nil {
		return []*VolumeInstance{}, nil
	}

	instances := make([]*VolumeInstance, len(*volumes))
	for i, volume := range *volumes {
		v := volume // Create a copy to avoid pointer issues
		instances[i] = &VolumeInstance{
			Volume:  &v,
			service: r,
			options: opts,
		}
	}

	return instances, nil
}

// DeleteInstance deletes a volume by name
func (r *VolumeService) DeleteInstance(ctx context.Context, volumeName string, opts ...option.RequestOption) error {
	opts = slices.Concat(r.Options, opts)
	_, err := r.Delete(ctx, volumeName, opts...)
	return err
}

// UpdateInstance updates a volume and returns a VolumeInstance
func (r *VolumeService) UpdateInstance(ctx context.Context, volumeName string, body VolumeUpdateParams, opts ...option.RequestOption) (*VolumeInstance, error) {
	opts = slices.Concat(r.Options, opts)

	volume, err := r.Update(ctx, volumeName, body, opts...)
	if err != nil {
		return nil, err
	}

	// This is for safe update
	time.Sleep(500 * time.Millisecond)

	return &VolumeInstance{
		Volume:  volume,
		service: r,
		options: opts,
	}, nil
}

// UpdateInstanceMetadata updates only the metadata of a volume
func (r *VolumeService) UpdateInstanceMetadata(ctx context.Context, volumeName string, metadata VolumeUpdateMetadataParams, opts ...option.RequestOption) (*VolumeInstance, error) {
	// Get current volume first
	instance, err := r.GetInstance(ctx, volumeName, opts...)
	if err != nil {
		return nil, err
	}

	// Unmarshal the raw JSON into VolumeParam so fields are populated and modifiable
	var volumeParam VolumeParam
	if err := json.Unmarshal([]byte(instance.Volume.RawJSON()), &volumeParam); err != nil {
		return nil, fmt.Errorf("failed to unmarshal volume: %w", err)
	}

	// Update metadata fields
	if metadata.Labels != nil {
		volumeParam.Metadata.Labels = metadata.Labels
	}
	if metadata.DisplayName != "" {
		volumeParam.Metadata.DisplayName = String(metadata.DisplayName)
	}

	updateParams := VolumeUpdateParams{
		Volume: volumeParam,
	}

	return r.UpdateInstance(ctx, volumeName, updateParams, opts...)
}

// CreateInstanceIfNotExists creates a volume if it doesn't exist, or returns the existing one
func (r *VolumeService) CreateInstanceIfNotExists(ctx context.Context, body VolumeNewParams, opts ...option.RequestOption) (*VolumeInstance, error) {
	instance, err := r.NewInstance(ctx, body, opts...)
	if err != nil {
		// Check if error indicates volume already exists (409 conflict)
		if strings.Contains(err.Error(), "409") || strings.Contains(err.Error(), "already exists") || strings.Contains(err.Error(), "VOLUME_ALREADY_EXISTS") {
			name := body.Volume.Metadata.Name
			if name == "" {
				return nil, err
			}
			return r.GetInstance(ctx, name, opts...)
		}
		return nil, err
	}
	return instance, nil
}

// generateShortID generates a short random ID for default names
func generateShortID() string {
	// Use crypto/rand for secure random ID generation
	bytes := make([]byte, 4)
	if _, err := rand.Read(bytes); err != nil {
		// Fallback to timestamp if crypto/rand fails
		return fmt.Sprintf("%x", time.Now().UnixNano()%0xFFFFFFFF)[:8]
	}
	return fmt.Sprintf("%x", bytes)
}
