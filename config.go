// File manually maintained - not generated by Stainless

package blaxel

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"

	"github.com/stainless-sdks/blaxel-go/internal/requestconfig"
	"gopkg.in/yaml.v3"
)

// Config represents the structure of ~/.blaxel/config.yaml
type Config struct {
	Context    ContextConfig     `yaml:"context"`
	Workspaces []WorkspaceConfig `yaml:"workspaces"`
	Tracking   bool              `yaml:"tracking"`
}

// WorkspaceConfig represents a workspace configuration
type WorkspaceConfig struct {
	Name        string      `yaml:"name"`
	Credentials Credentials `yaml:"credentials"`
	Env         string      `yaml:"env"`
}

// ContextConfig represents the current context
type ContextConfig struct {
	Workspace string `yaml:"workspace"`
}

// Credentials represents authentication credentials
type Credentials struct {
	APIKey            string `yaml:"apiKey"`
	AccessToken       string `yaml:"access_token"`
	RefreshToken      string `yaml:"refresh_token"`
	ExpiresIn         int    `yaml:"expires_in"`
	DeviceCode        string `yaml:"device_code"`
	ClientCredentials string `yaml:"client_credentials"`
}

// IsValid returns true if any credential is set
func (c Credentials) IsValid() bool {
	return c.APIKey != "" || c.AccessToken != "" || c.RefreshToken != "" || c.ClientCredentials != ""
}

// AuthHeaders returns the authentication headers for HTTP requests.
// It handles token refresh and client credentials exchange as needed.
func (c Credentials) AuthHeaders(ctx context.Context, workspace string) (map[string]string, error) {
	headers := make(map[string]string)

	if c.APIKey != "" {
		headers["X-Blaxel-Authorization"] = "Bearer " + c.APIKey
	} else if c.AccessToken != "" && c.RefreshToken != "" {
		// Access token with refresh token - check if refresh needed
		baseURL, _ := url.Parse(GetBaseURL())
		cfg := &requestconfig.RequestConfig{
			Context:            ctx,
			Workspace:          workspace,
			AccessToken:        c.AccessToken,
			RefreshToken:       c.RefreshToken,
			DeviceCode:         c.DeviceCode,
			ExpiresIn:          c.ExpiresIn,
			BaseURL:            baseURL,
			HTTPClient:         http.DefaultClient,
			OAuth2RefreshState: requestconfig.OAuth2RefreshCache,
		}
		token, err := requestconfig.OAuth2RefreshCache.GetToken(cfg)
		if err != nil {
			return nil, fmt.Errorf("failed to refresh token: %w", err)
		}
		headers["X-Blaxel-Authorization"] = "Bearer " + token
	} else if c.AccessToken != "" {
		headers["X-Blaxel-Authorization"] = "Bearer " + c.AccessToken
	} else if c.ClientCredentials != "" {
		// Decode and exchange client credentials for token
		decoded, err := base64.StdEncoding.DecodeString(c.ClientCredentials)
		if err != nil {
			decoded = []byte(c.ClientCredentials)
		}
		parts := strings.SplitN(string(decoded), ":", 2)
		if len(parts) != 2 {
			return nil, fmt.Errorf("invalid client credentials format")
		}

		baseURL, _ := url.Parse(GetBaseURL())
		oauthState := requestconfig.OAuth2Cache["/oauth/token"]
		cfg := &requestconfig.RequestConfig{
			Context:      ctx,
			ClientID:     parts[0],
			ClientSecret: parts[1],
			BaseURL:      baseURL,
			HTTPClient:   http.DefaultClient,
			OAuth2State:  oauthState,
		}
		token, err := oauthState.GetToken(cfg)
		if err != nil {
			return nil, fmt.Errorf("failed to get client credentials token: %w", err)
		}
		headers["X-Blaxel-Authorization"] = "Bearer " + token
	}

	if workspace != "" {
		headers["X-Blaxel-Workspace"] = workspace
	}

	return headers, nil
}

// LoadConfig loads the configuration from ~/.blaxel/config.yaml
func LoadConfig() (Config, error) {
	config := Config{}
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return config, err
	}

	configPath := filepath.Join(homeDir, ".blaxel", "config.yaml")
	data, err := os.ReadFile(configPath)
	if err != nil {
		// If file doesn't exist, return empty config (not an error)
		if os.IsNotExist(err) {
			return config, nil
		}
		return config, err
	}

	if err := yaml.Unmarshal(data, &config); err != nil {
		// Invalid YAML, return empty config
		return Config{}, nil
	}

	return config, nil
}

// LoadCredentials loads credentials for a specific workspace
func LoadCredentials(workspaceName string) (Credentials, error) {
	config, err := LoadConfig()
	if err != nil {
		return Credentials{}, err
	}

	for _, workspace := range config.Workspaces {
		if workspace.Name == workspaceName {
			return workspace.Credentials, nil
		}
	}

	return Credentials{}, nil
}

// SaveCredentials saves updated credentials for a specific workspace
func SaveCredentials(workspaceName string, creds Credentials) error {
	config, err := LoadConfig()
	if err != nil {
		// Initialize empty config if it doesn't exist
		config = Config{
			Workspaces: []WorkspaceConfig{},
		}
	}

	// Find and update the workspace credentials
	found := false
	for i, workspace := range config.Workspaces {
		if workspace.Name == workspaceName {
			config.Workspaces[i].Credentials = creds
			found = true
			break
		}
	}

	// If workspace not found, add it
	if !found {
		configWorkspace := WorkspaceConfig{
			Name:        workspaceName,
			Credentials: creds,
		}
		environment := GetEnvironment()
		if environment != "prod" {
			configWorkspace.Env = string(environment)
		}
		config.Workspaces = append(config.Workspaces, configWorkspace)
	}

	return WriteConfig(config)
}

// SetCurrentWorkspace sets the current workspace in the config
func SetCurrentWorkspace(workspaceName string) error {
	config, err := LoadConfig()
	if err != nil {
		config = Config{}
	}

	config.Context.Workspace = workspaceName
	return WriteConfig(config)
}

// WriteConfig writes the config to file
func WriteConfig(config Config) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	configPath := filepath.Join(home, ".blaxel")

	// Ensure directory exists
	if err := os.MkdirAll(configPath, 0755); err != nil {
		return err
	}

	var buf bytes.Buffer

	// Write context
	buf.WriteString("context:\n")
	buf.WriteString(fmt.Sprintf("  workspace: %s\n", config.Context.Workspace))

	// Write workspaces
	buf.WriteString("workspaces:\n")
	for _, ws := range config.Workspaces {
		buf.WriteString(fmt.Sprintf("- name: %s\n", ws.Name))
		buf.WriteString("  credentials:\n")
		if ws.Credentials.APIKey != "" {
			buf.WriteString(fmt.Sprintf("    apiKey: \"%s\"\n", ws.Credentials.APIKey))
		}
		if ws.Credentials.AccessToken != "" {
			buf.WriteString(fmt.Sprintf("    access_token: %s\n", ws.Credentials.AccessToken))
		}
		if ws.Credentials.RefreshToken != "" {
			buf.WriteString(fmt.Sprintf("    refresh_token: %s\n", ws.Credentials.RefreshToken))
		}
		if ws.Credentials.ExpiresIn > 0 {
			buf.WriteString(fmt.Sprintf("    expires_in: %d\n", ws.Credentials.ExpiresIn))
		}
		if ws.Credentials.DeviceCode != "" {
			buf.WriteString(fmt.Sprintf("    device_code: %s\n", ws.Credentials.DeviceCode))
		}
		if ws.Credentials.ClientCredentials != "" {
			buf.WriteString(fmt.Sprintf("    client_credentials: \"%s\"\n", ws.Credentials.ClientCredentials))
		}
		if ws.Env != "" {
			buf.WriteString(fmt.Sprintf("  env: \"%s\"\n", ws.Env))
		}
	}

	// Write tracking
	buf.WriteString(fmt.Sprintf("tracking: %v\n", config.Tracking))

	return os.WriteFile(filepath.Join(configPath, "config.yaml"), buf.Bytes(), 0600)
}

// CurrentContext returns the current workspace context
func CurrentContext() (ContextConfig, error) {
	config, err := LoadConfig()
	if err != nil {
		return ContextConfig{}, err
	}
	return config.Context, nil
}

// IsTrackingEnabled returns true if tracking is enabled (not explicitly disabled)
func IsTrackingEnabled() bool {
	// Tracking is disabled if DO_NOT_TRACK is set
	if os.Getenv("DO_NOT_TRACK") == "1" {
		return false
	}
	return true
}

// isTrackingConfigured checks if tracking has been explicitly configured
func IsTrackingConfigured() bool {
	// Environment variable counts as configured
	if os.Getenv("DO_NOT_TRACK") != "" {
		return true
	}

	// Check if config file exists and has tracking field
	home, err := os.UserHomeDir()
	if err != nil {
		return false
	}

	data, err := os.ReadFile(filepath.Join(home, ".blaxel", "config.yaml"))
	if err != nil {
		return false // Config doesn't exist yet
	}

	// Check if the config file contains a tracking setting
	content := string(data)
	return strings.Contains(content, "tracking:")
}

// SetTracking saves the tracking preference
func SetTracking(enabled bool) {
	// Set environment variable for this session
	if !enabled {
		os.Setenv("DO_NOT_TRACK", "1")
	}

	// Save to config file
	config, err := LoadConfig()
	if err != nil {
		// Initialize empty config if it doesn't exist
		config = Config{
			Workspaces: []WorkspaceConfig{},
		}
	}

	config.Tracking = enabled
	// Silently fail - tracking preference is not critical
	_ = WriteConfig(config)
}
