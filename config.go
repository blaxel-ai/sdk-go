// File manually maintained - not generated by Stainless

package blaxel

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// Config represents the structure of ~/.blaxel/config.yaml
type Config struct {
	Context    ContextConfig     `yaml:"context"`
	Workspaces []WorkspaceConfig `yaml:"workspaces"`
	Tracking   bool              `yaml:"tracking"`
}

// WorkspaceConfig represents a workspace configuration
type WorkspaceConfig struct {
	Name        string      `yaml:"name"`
	Credentials Credentials `yaml:"credentials"`
	Env         string      `yaml:"env"`
}

// ContextConfig represents the current context
type ContextConfig struct {
	Workspace string `yaml:"workspace"`
}

// Credentials represents authentication credentials
type Credentials struct {
	APIKey            string `yaml:"apiKey"`
	AccessToken       string `yaml:"access_token"`
	RefreshToken      string `yaml:"refresh_token"`
	ExpiresIn         int    `yaml:"expires_in"`
	DeviceCode        string `yaml:"device_code"`
	ClientCredentials string `yaml:"client_credentials"`
}

// IsValid returns true if any credential is set
func (c Credentials) IsValid() bool {
	return c.APIKey != "" || c.AccessToken != "" || c.RefreshToken != "" || c.ClientCredentials != ""
}

// LoadConfig loads the configuration from ~/.blaxel/config.yaml
func LoadConfig() (Config, error) {
	config := Config{}
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return config, err
	}

	configPath := filepath.Join(homeDir, ".blaxel", "config.yaml")
	data, err := os.ReadFile(configPath)
	if err != nil {
		// If file doesn't exist, return empty config (not an error)
		if os.IsNotExist(err) {
			return config, nil
		}
		return config, err
	}

	if err := yaml.Unmarshal(data, &config); err != nil {
		// Invalid YAML, return empty config
		return Config{}, nil
	}

	return config, nil
}

// LoadCredentials loads credentials for a specific workspace
func LoadCredentials(workspaceName string) (Credentials, error) {
	config, err := LoadConfig()
	if err != nil {
		return Credentials{}, err
	}

	for _, workspace := range config.Workspaces {
		if workspace.Name == workspaceName {
			return workspace.Credentials, nil
		}
	}

	return Credentials{}, nil
}

// SaveCredentials saves updated credentials for a specific workspace
func SaveCredentials(workspaceName string, creds Credentials) error {
	config, err := LoadConfig()
	if err != nil {
		// Initialize empty config if it doesn't exist
		config = Config{
			Workspaces: []WorkspaceConfig{},
		}
	}

	// Find and update the workspace credentials
	found := false
	for i, workspace := range config.Workspaces {
		if workspace.Name == workspaceName {
			config.Workspaces[i].Credentials = creds
			found = true
			break
		}
	}

	// If workspace not found, add it
	if !found {
		config.Workspaces = append(config.Workspaces, WorkspaceConfig{
			Name:        workspaceName,
			Credentials: creds,
		})
	}

	return writeConfig(config)
}

// writeConfig writes the config to file
func writeConfig(config Config) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	configPath := filepath.Join(home, ".blaxel")

	// Ensure directory exists
	if err := os.MkdirAll(configPath, 0755); err != nil {
		return err
	}

	var buf bytes.Buffer

	// Write context
	buf.WriteString("context:\n")
	buf.WriteString(fmt.Sprintf("  workspace: %s\n", config.Context.Workspace))

	// Write workspaces
	buf.WriteString("workspaces:\n")
	for _, ws := range config.Workspaces {
		buf.WriteString(fmt.Sprintf("- name: %s\n", ws.Name))
		buf.WriteString("  credentials:\n")
		if ws.Credentials.APIKey != "" {
			buf.WriteString(fmt.Sprintf("    apiKey: \"%s\"\n", ws.Credentials.APIKey))
		}
		if ws.Credentials.AccessToken != "" {
			buf.WriteString(fmt.Sprintf("    access_token: %s\n", ws.Credentials.AccessToken))
		}
		if ws.Credentials.RefreshToken != "" {
			buf.WriteString(fmt.Sprintf("    refresh_token: %s\n", ws.Credentials.RefreshToken))
		}
		if ws.Credentials.ExpiresIn > 0 {
			buf.WriteString(fmt.Sprintf("    expires_in: %d\n", ws.Credentials.ExpiresIn))
		}
		if ws.Credentials.DeviceCode != "" {
			buf.WriteString(fmt.Sprintf("    device_code: %s\n", ws.Credentials.DeviceCode))
		}
		if ws.Credentials.ClientCredentials != "" {
			buf.WriteString(fmt.Sprintf("    client_credentials: \"%s\"\n", ws.Credentials.ClientCredentials))
		}
		if ws.Env != "" {
			buf.WriteString(fmt.Sprintf("  env: \"%s\"\n", ws.Env))
		}
	}

	// Write tracking
	buf.WriteString(fmt.Sprintf("tracking: %v\n", config.Tracking))

	return os.WriteFile(filepath.Join(configPath, "config.yaml"), buf.Bytes(), 0600)
}

// CurrentContext returns the current workspace context
func CurrentContext() (ContextConfig, error) {
	config, err := LoadConfig()
	if err != nil {
		return ContextConfig{}, err
	}
	return config.Context, nil
}

// IsTrackingEnabled returns true if tracking is enabled (not explicitly disabled)
func IsTrackingEnabled() bool {
	// Tracking is disabled if DO_NOT_TRACK is set
	if os.Getenv("DO_NOT_TRACK") == "1" {
		return false
	}
	return true
}

// isTrackingConfigured checks if tracking has been explicitly configured
func IsTrackingConfigured() bool {
	// Environment variable counts as configured
	if os.Getenv("DO_NOT_TRACK") != "" {
		return true
	}

	// Check if config file exists and has tracking field
	home, err := os.UserHomeDir()
	if err != nil {
		return false
	}

	data, err := os.ReadFile(filepath.Join(home, ".blaxel", "config.yaml"))
	if err != nil {
		return false // Config doesn't exist yet
	}

	// Check if the config file contains a tracking setting
	content := string(data)
	return strings.Contains(content, "tracking:")
}

// SetTracking saves the tracking preference (placeholder - would need config file update)
func SetTracking(enabled bool) {
	// Set environment variable for this session
	if !enabled {
		os.Setenv("DO_NOT_TRACK", "1")
	}

	// Save to config file
	config, err := LoadConfig()
	if err != nil {
		// Initialize empty config if it doesn't exist
		config = Config{
			Workspaces: []WorkspaceConfig{},
		}
	}

	// Write config with tracking setting
	if err := writeConfigWithTracking(config, enabled); err != nil {
		// Silently fail - tracking preference is not critical
		return
	}
}

// writeConfigWithTracking writes the config to file with the tracking setting
func writeConfigWithTracking(config Config, tracking bool) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return err
	}
	configPath := filepath.Join(home, ".blaxel")

	// Ensure directory exists
	if err := os.MkdirAll(configPath, 0755); err != nil {
		return err
	}

	var buf bytes.Buffer

	// Write context
	buf.WriteString("context:\n")
	buf.WriteString(fmt.Sprintf("  workspace: %s\n", config.Context.Workspace))

	// Write workspaces
	buf.WriteString("workspaces:\n")
	for _, ws := range config.Workspaces {
		buf.WriteString(fmt.Sprintf("- name: %s\n", ws.Name))
		buf.WriteString("  credentials:\n")
		buf.WriteString(fmt.Sprintf("    apiKey: \"%s\"\n", ws.Credentials.APIKey))
		buf.WriteString(fmt.Sprintf("    access_token: %s\n", ws.Credentials.AccessToken))
		buf.WriteString(fmt.Sprintf("    refresh_token: %s\n", ws.Credentials.RefreshToken))
		buf.WriteString(fmt.Sprintf("    expires_in: %d\n", ws.Credentials.ExpiresIn))
		buf.WriteString(fmt.Sprintf("    device_code: %s\n", ws.Credentials.DeviceCode))
		buf.WriteString(fmt.Sprintf("    client_credentials: \"%s\"\n", ws.Credentials.ClientCredentials))
		buf.WriteString(fmt.Sprintf("  env: \"%s\"\n", ws.Env))
	}

	// Write tracking
	buf.WriteString(fmt.Sprintf("tracking: %v\n", tracking))

	return os.WriteFile(filepath.Join(configPath, "config.yaml"), buf.Bytes(), 0600)
}
