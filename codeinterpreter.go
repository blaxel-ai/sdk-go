// File manually maintained - not generated by Stainless

package blaxel

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"slices"
	"time"

	"github.com/stainless-sdks/blaxel-go/internal/requestconfig"
	"github.com/stainless-sdks/blaxel-go/option"
)

const (
	// DefaultCodeInterpreterImage is the default image for CodeInterpreter sandboxes
	DefaultCodeInterpreterImage = "blaxel/jupyter-server"
	// DefaultCodeInterpreterPort is the Jupyter server port
	DefaultCodeInterpreterPort = 8888
)

// CodeInterpreter extends SandboxInstance with Jupyter code execution capabilities
type CodeInterpreter struct {
	*SandboxInstance
	sandboxConfig *Sandbox
	options       []option.RequestOption
}

// OutputMessage represents a stdout or stderr message from code execution
type OutputMessage struct {
	Text      string
	Timestamp *int64
	IsStderr  bool
}

// ExecutionResult represents a result from code execution
type ExecutionResult map[string]interface{}

// ExecutionError represents an error from code execution
type ExecutionError struct {
	Name      string
	Value     interface{}
	Traceback interface{}
}

// ExecutionLogs contains stdout and stderr logs
type ExecutionLogs struct {
	Stdout []string
	Stderr []string
}

// Execution represents the result of running code
type Execution struct {
	Results        []ExecutionResult
	Logs           ExecutionLogs
	Error          *ExecutionError
	ExecutionCount *int64
}

// CodeContext represents a Jupyter kernel context
type CodeContext struct {
	ID string
}

// RunCodeOptions contains options for running code
type RunCodeOptions struct {
	Language       string
	Context        *CodeContext
	OnStdout       func(msg OutputMessage)
	OnStderr       func(msg OutputMessage)
	OnResult       func(result ExecutionResult)
	OnError        func(err ExecutionError)
	Envs           map[string]string
	Timeout        time.Duration
	RequestTimeout time.Duration
}

// CreateContextOptions contains options for creating a code context
type CreateContextOptions struct {
	Cwd            string
	Language       string
	RequestTimeout time.Duration
}

// CodeInterpreterCreateConfig contains options for creating a CodeInterpreter
type CodeInterpreterCreateConfig struct {
	Name   string
	Memory int64
	Region string
	Envs   []SandboxRuntimeEnvParam
	Labels map[string]string
}

// NewCodeInterpreter creates a new CodeInterpreter sandbox
func (r *SandboxService) NewCodeInterpreter(ctx context.Context, config *CodeInterpreterCreateConfig, opts ...option.RequestOption) (*CodeInterpreter, error) {
	if config == nil {
		config = &CodeInterpreterCreateConfig{}
	}

	opts = slices.Concat(r.Options, opts)

	// Build sandbox configuration with Jupyter defaults
	name := config.Name
	if name == "" {
		name = fmt.Sprintf("jupyter-%s", generateShortID())
	}

	memory := config.Memory
	if memory == 0 {
		memory = 4096
	}

	sandboxParams := SandboxNewParams{
		Sandbox: SandboxParam{
			Metadata: MetadataParam{
				Name:   name,
				Labels: config.Labels,
			},
			Spec: SandboxSpecParam{
				Region: String(config.Region),
				Runtime: SandboxRuntimeParam{
					Image:  String(DefaultCodeInterpreterImage),
					Memory: Int(memory),
					Ports: []PortParam{
						{
							Name:     String("jupyter"),
							Target:   DefaultCodeInterpreterPort,
							Protocol: PortProtocolHTTP,
						},
					},
					Envs: config.Envs,
				},
				Lifecycle: SandboxLifecycleParam{
					ExpirationPolicies: []ExpirationPolicyParam{
						{
							Type:   ExpirationPolicyTypeTtlIdle,
							Value:  String("30m"),
							Action: ExpirationPolicyActionDelete,
						},
					},
				},
			},
		},
	}

	instance, err := r.NewInstance(ctx, sandboxParams, opts...)
	if err != nil {
		return nil, err
	}

	return &CodeInterpreter{
		SandboxInstance: instance,
		sandboxConfig:   instance.Sandbox,
		options:         instance.options,
	}, nil
}

// GetCodeInterpreter returns an existing sandbox as a CodeInterpreter
func (r *SandboxService) GetCodeInterpreter(ctx context.Context, sandboxName string, opts ...option.RequestOption) (*CodeInterpreter, error) {
	opts = slices.Concat(r.Options, opts)

	instance, err := r.GetInstance(ctx, sandboxName, opts...)
	if err != nil {
		return nil, err
	}

	return &CodeInterpreter{
		SandboxInstance: instance,
		sandboxConfig:   instance.Sandbox,
		options:         instance.options,
	}, nil
}

// RunCode executes code in the Jupyter kernel.
// Note: Raw HTTP is used because this calls the Jupyter server endpoint (/port/8888/execute)
// which is not part of the generated sandbox API. It also streams results incrementally.
func (c *CodeInterpreter) RunCode(ctx context.Context, code string, opts *RunCodeOptions) (*Execution, error) {
	if opts == nil {
		opts = &RunCodeOptions{}
	}

	if opts.Language != "" && opts.Context != nil {
		return nil, fmt.Errorf("you can provide context or language, but not both at the same time")
	}

	timeout := opts.Timeout
	if timeout == 0 {
		timeout = 60 * time.Second
	}

	// Create context with timeout
	if timeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, timeout)
		defer cancel()
	}

	// Build request body
	body := map[string]interface{}{
		"code":     code,
		"language": opts.Language,
		"env_vars": opts.Envs,
	}
	if opts.Context != nil {
		body["context_id"] = opts.Context.ID
	}

	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	// Build the request path (relative to sandbox base URL)
	path := fmt.Sprintf("port/%d/execute", DefaultCodeInterpreterPort)

	// Create config and prepare request (resolves URL, applies auth)
	cfg, err := requestconfig.NewRequestConfig(ctx, http.MethodPost, path, nil, nil, c.options...)
	if err != nil {
		return nil, err
	}

	req, client, err := cfg.PrepareRequest()
	if err != nil {
		return nil, err
	}

	// Set the body
	req.Body = io.NopCloser(bytes.NewReader(bodyBytes))
	req.ContentLength = int64(len(bodyBytes))
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		bodyText, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("execution failed: %s %s", resp.Status, string(bodyText))
	}

	execution := &Execution{
		Results: []ExecutionResult{},
		Logs: ExecutionLogs{
			Stdout: []string{},
			Stderr: []string{},
		},
	}

	// Parse streaming response
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := scanner.Text()
		if line == "" {
			continue
		}

		c.parseOutput(execution, line, opts)
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return execution, nil
}

// parseOutput parses a line of output from the Jupyter execution
func (c *CodeInterpreter) parseOutput(execution *Execution, output string, opts *RunCodeOptions) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(output), &data); err != nil {
		// Fallback: treat as stdout text-only message
		execution.Logs.Stdout = append(execution.Logs.Stdout, output)
		if opts.OnStdout != nil {
			opts.OnStdout(OutputMessage{Text: output, IsStderr: false})
		}
		return
	}

	dataType, _ := data["type"].(string)

	switch dataType {
	case "result":
		delete(data, "type")
		result := ExecutionResult(data)
		execution.Results = append(execution.Results, result)
		if opts.OnResult != nil {
			opts.OnResult(result)
		}

	case "stdout":
		text, _ := data["text"].(string)
		execution.Logs.Stdout = append(execution.Logs.Stdout, text)
		if opts.OnStdout != nil {
			var timestamp *int64
			if ts, ok := data["timestamp"].(float64); ok {
				t := int64(ts)
				timestamp = &t
			}
			opts.OnStdout(OutputMessage{Text: text, Timestamp: timestamp, IsStderr: false})
		}

	case "stderr":
		text, _ := data["text"].(string)
		execution.Logs.Stderr = append(execution.Logs.Stderr, text)
		if opts.OnStderr != nil {
			var timestamp *int64
			if ts, ok := data["timestamp"].(float64); ok {
				t := int64(ts)
				timestamp = &t
			}
			opts.OnStderr(OutputMessage{Text: text, Timestamp: timestamp, IsStderr: true})
		}

	case "error":
		name, _ := data["name"].(string)
		execError := ExecutionError{
			Name:      name,
			Value:     data["value"],
			Traceback: data["traceback"],
		}
		execution.Error = &execError
		if opts.OnError != nil {
			opts.OnError(execError)
		}

	case "number_of_executions":
		if count, ok := data["execution_count"].(float64); ok {
			c := int64(count)
			execution.ExecutionCount = &c
		}
	}
}

// CreateCodeContext creates a new Jupyter kernel context.
// Note: Raw HTTP is used because this calls the Jupyter server endpoint (/port/8888/contexts)
// which is not part of the generated sandbox API.
func (c *CodeInterpreter) CreateCodeContext(ctx context.Context, opts *CreateContextOptions) (*CodeContext, error) {
	if opts == nil {
		opts = &CreateContextOptions{}
	}

	// Apply timeout if specified
	if opts.RequestTimeout > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithTimeout(ctx, opts.RequestTimeout)
		defer cancel()
	}

	body := map[string]interface{}{}
	if opts.Language != "" {
		body["language"] = opts.Language
	}
	if opts.Cwd != "" {
		body["cwd"] = opts.Cwd
	}

	bodyBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	// Build the request path (relative to sandbox base URL)
	path := fmt.Sprintf("port/%d/contexts", DefaultCodeInterpreterPort)

	// Create config and prepare request (resolves URL, applies auth)
	cfg, err := requestconfig.NewRequestConfig(ctx, http.MethodPost, path, nil, nil, c.options...)
	if err != nil {
		return nil, err
	}

	req, client, err := cfg.PrepareRequest()
	if err != nil {
		return nil, err
	}

	// Set the body
	req.Body = io.NopCloser(bytes.NewReader(bodyBytes))
	req.ContentLength = int64(len(bodyBytes))
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		bodyText, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("create context failed: %s %s", resp.Status, string(bodyText))
	}

	var responseData map[string]interface{}
	if err := json.NewDecoder(resp.Body).Decode(&responseData); err != nil {
		return nil, err
	}

	// Extract context ID
	var contextID string
	if id, ok := responseData["id"].(string); ok {
		contextID = id
	} else if id, ok := responseData["context_id"].(string); ok {
		contextID = id
	}

	return &CodeContext{ID: contextID}, nil
}
